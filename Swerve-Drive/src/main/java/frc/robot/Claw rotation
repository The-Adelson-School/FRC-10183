import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.Timer;

public class ElevatorRobot extends TimedRobot {

    private CANSparkMax elevatorMotor;
    private XboxController controller;
    private Timer timer;

    private final double STAGE_1_HEIGHT = 0.3; // feet (f)
    private final double STAGE_2_HEIGHT = 0.66; // f
    private final double STAGE_3_HEIGHT = 1.0; // change this and two above with accurate values
    private final double TOTAL_CLIMB_TIME = 2.0; // seconds (s)
    private final double GEAR_RATIO = 9.0; 

    private double targetHeight = 0.0; // this is also in f
    private double currentHeight = 0.0; // in f
    private double startTime = 0.0;

    @Override
    public void robotInit() {
        elevatorMotor = new CANSparkMax(1, MotorType.kBrushless); // reminder to replace 1 with  CAN ID
        controller = new XboxController(0); // reminder to replace 0 with controller port
        timer = new Timer();
        elevatorMotor.getEncoder().setPosition(0); 
    }

    @Override
    public void teleopPeriodic() {
        if (controller.getXButtonPressed()) {
            targetHeight = STAGE_1_HEIGHT;
            startTime = timer.getFPGATimestamp();
        } else if (controller.getYButtonPressed()) {
            targetHeight = STAGE_2_HEIGHT;
            startTime = timer.getFPGATimestamp();
        } else if (controller.getAButtonPressed()) {
            targetHeight = STAGE_3_HEIGHT;
            startTime = timer.getFPGATimestamp();
        }

        double elapsedTime = timer.getFPGATimestamp() - startTime;
        if (elapsedTime <= TOTAL_CLIMB_TIME) {
            currentHeight = calculateCurrentHeight(elapsedTime);
            double motorRotations = feetToRotations(currentHeight);
            elevatorMotor.getEncoder().setPosition(motorRotations);
            double speed = calculateSpeed(currentHeight, targetHeight, elapsedTime);
            elevatorMotor.set(speed);
        } else {
            double motorRotations = feetToRotations(targetHeight);
            elevatorMotor.getEncoder().setPosition(motorRotations);
            elevatorMotor.set(calculateSpeed(targetHeight, targetHeight, TOTAL_CLIMB_TIME));
        }
    }

    private double calculateCurrentHeight(double elapsedTime) {
        if(elapsedTime > TOTAL_CLIMB_TIME) return targetHeight;
        return targetHeight * (elapsedTime / TOTAL_CLIMB_TIME);
    }

    private double feetToRotations(double feet) {
        
        double feetPerRotation = 0.166; // make sure this is accurate
        return (feet / feetPerRotation) * GEAR_RATIO;
    }

    private double calculateSpeed(double currentHeight, double targetHeight, double elapsedTime) {

        double distanceToTarget = targetHeight - currentHeight;
        if (elapsedTime <= 0) {
            return 0;
        }

        if(elapsedTime >= TOTAL_CLIMB_TIME) {
            return 0;
        }
        return distanceToTarget / (TOTAL_CLIMB_TIME);

    }
}
